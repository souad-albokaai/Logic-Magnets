1.
هذا المشروع عبارة عن لعبة "مغناطيسات المنطق"، والهدف منها هو استخدام المغناطيسات والأحجار لجعل جميع الدوائر البيضاء مغطاة. أنا استخدمت خوارزميتين للبحث عن الحل: البحث عمق-الأول (DFS) والبحث عرض-الثاني (BFS) 
 مشان  اللعبة تقدر تحل نفسها وتوصل للهدف المطلوب 

2. هيكل الكود بشكل عام
الكود مقسّم لكائنات، منها:

Board: هذا الكلاس يمثل اللوحة، وهو المكان اللي بتم فيه الحركات لكل الأحجار.
GameLogic: هنا بعمل خوارزميات البحث (DFS و BFS) بتحقق إذا اللعبة وصلت لحل او لسى
GameState:   أستخدمه لتخزين حالات معينة للحركة أو أي معلومات ثانية بدي أحتفظ فيها
3. شرح الكود بالتفصيل
GameLogic
bfs()
 
(BFS) تبحث بشكل عريض، يعني بتجرب كل الحركات الممكنة اللي بتوسعها وبتتقدم خطوة خطوة
 Board   إذا وصلنا للهدف،بيرجع
 وnull  و بيرجع إذا ما كان في حل
dfs()

 (DFS)
  ببحث في عمق المسار، وبيفحص المسار الأقرب للنهاية أولاً
بيرجع كائن Board 
إذا وصلنا للهدف
 null و إذا ما لقى حل

getNextStates()
 هذه الدالة بتولّد كل الحالات الممكنة لحركة المغناطيس الأحمر أو الوردي. لما يتحرك أي مغناطيس، بتحدث تغييرات في أماكن الأحجار الحديدية اللي بتتأثر بالمغناطيس
بيرجع: قائمة List بكل الحالات الجديدة الممكنة

buildSolutionPath()
 بستخدم هذه الدالة مشان أبني المسار للحل من أول خطوة لآخر خطوة بعد ما نوصل للحل
بيرجع: قائمة List بالخطوات اللي عملتها للوصول للحل.
printSolutionPath()

 هي بتطبع مسار الحل على الشاشة مشان أشوف كيف اللعبة وصلت للهدف
 ما بيرجع شي (void) بس بيطبع الخطوات

Board:
moveStone(int fromRow, int fromCol, int toRow, int toCol)

 تنقل حجر مغناطيسي من مكان لمكان ثاني، وبتعيد ترتيب الأحجار حسب التأثير المغناطيسي
 ما بيرجع شي، بس بيعدل اللوحة مباشرة

isGoalState()

 بتتحقق إذا اللوحة في حالة الهدف (كل الدوائر البيضاء مغطاة
بيرجع
 boolean (صحيح أو خطأ) حسب إذا الهدف اتحقق أو لا
4. كيف خزنت حالات اللعبة

خزّنت كل حالة جديدة بزيارتها في visitedStates مشان أتأكد إنه ما في تكرار في فحص الحالات

ولما أكون حالة جديدة، بحطها في
 parentMap مع الحالة اللي جت منها
 
وبهالطريقة بقدر أبني مسار الحل النهائي لما نصل للهدف
5. كيف بحثت عن الحل

بدأت البحث: بأختار البحث عرض-الأول (BFS) أو عمق-الأول (DFS) من GameLogic وتبدا اللعبة من الوضعية الابتدائية
توليد الحالات: كل حركة بتنتج حالات جديدة حسب مواقع الأحجار والمغناطيسات
التأكد من الهدف: إذا كانت اللوحة وصلت للهدف (كل الدوائر مغطاة)، بستخدم
 buildSolutionPath() لبناء الخطوات للوصول للحل

طباعة الحل: بطبع المسار النهائي باستخدام printSolutionPath()
 مشان أشوف كل خطوة للوصول للحل .
